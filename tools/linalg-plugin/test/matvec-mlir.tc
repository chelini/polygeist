// RUN: linalg-plugin-opt %s --show-mlir | FileCheck %s

__start_tc

def matvec(float32(N) b, float32(N, N) A) -> (float32(N) x)
{
  x(i) +=! A(i,j) * b(j) where i in 0:N, j in 0:N
}

__end_tc

// CHECK: #[[MAP:.+]] = affine_map<(d0, d1) -> (d0, d1)>
// CHECK-DAG: #[[MAP1:.+]] = affine_map<(d0, d1) -> (d1)>
// CHECK-DAG: #[[MAP2:.+]] = affine_map<(d0, d1) -> (d0)>

// CHECK-LABEL: matvec
// CHECK-SAME: %[[ARG0:.+]]: memref<?xf32>, %[[ARG1:.+]]: memref<?x?xf32>, %[[ARG2:.+]]: memref<?xf32>
// CHECK: %[[CST:.+]] = arith.constant 0.000000e+00 : f32
// CHECK: linalg.fill ins(%[[CST]] : f32) outs(%[[ARG2]] : memref<?xf32>)
// CHECK: linalg.generic
// CHECK-SAME: indexing_maps = [#[[MAP]], #[[MAP1]], #[[MAP2]]]
// CHECK-SAME: iterator_types = ["parallel", "reduction"]
// CHECK-SAME: ins(%[[ARG1]], %[[ARG0]] : memref<?x?xf32>, memref<?xf32>) outs(%[[ARG2]] : memref<?xf32>)
// CHECK: ^bb0(%[[IN:.+]]: f32, %[[IN0:.+]]: f32, %[[OUT:.+]]: f32):
// CHECK: %[[MUL:.+]] = arith.mulf %[[IN]], %[[IN0]] : f32
// CHECK: %[[ADD:.+]] = arith.addf %[[MUL]], %[[OUT]] : f32
// CHECK: linalg.yield %[[ADD]] : f32
